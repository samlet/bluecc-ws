/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : TcpConnection.sm
 */


//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
// 
// The Original Code is State Machine Compiler (SMC).
// 
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2000 - 2003 Charles W. Rapp.
// All Rights Reserved.
// 
// Contributor(s): 
//
// Name
//  TcpConnection.sm
//
// Description
//  The TCP/IP state transition diagram.
//
// RCS ID
// Id: TcpConnection.sm,v 1.7 2007/12/28 12:34:40 cwrapp Exp
//
// CHANGE LOG
// Log: TcpConnection.sm,v
// Revision 1.7  2007/12/28 12:34:40  cwrapp
// Version 5.0.1 check-in.
//
// Revision 1.6  2005/11/07 19:34:54  cwrapp
// Changes in release 4.3.0:
// New features:
//
// + Added -reflect option for Java, C#, VB.Net and Tcl code
//   generation. When used, allows applications to query a state
//   about its supported transitions. Returns a list of transition
//   names. This feature is useful to GUI developers who want to
//   enable/disable features based on the current state. See
//   Programmer's Manual section 11: On Reflection for more
//   information.
//
// + Updated LICENSE.txt with a missing final paragraph which allows
//   MPL 1.1 covered code to work with the GNU GPL.
//
// + Added a Maven plug-in and an ant task to a new tools directory.
//   Added Eiten Suez's SMC tutorial (in PDF) to a new docs
//   directory.
//
// Fixed the following bugs:
//
// + (GraphViz) DOT file generation did not properly escape
//   double quotes appearing in transition guards. This has been
//   corrected.
//
// + A note: the SMC FAQ incorrectly stated that C/C++ generated
//   code is thread safe. This is wrong. C/C++ generated is
//   certainly *not* thread safe. Multi-threaded C/C++ applications
//   are required to synchronize access to the FSM to allow for
//   correct performance.
//
// + (Java) The generated getState() method is now public.
//
// Revision 1.5  2005/05/28 13:51:24  cwrapp
// Update Java examples 1 - 7.
//
// Revision 1.1  2005/02/21 14:18:34  charlesr
// Added spaced around import class to test SMC.
//
// Revision 1.0  2003/12/14 20:19:48  charlesr
// Initial revision
//


package com.bluecc.ws.charts.fixtures.ex6;

import java.net.InetAddress;

public class TcpConnectionContext
    extends statemap.FSMContext
{
//---------------------------------------------------------------
// Member methods.
//

    public TcpConnectionContext(TcpConnection owner)
    {
        this (owner, MainMap.CLOSED);
    }

    public TcpConnectionContext(TcpConnection owner, TcpConnectionState initState)
    {
        super (initState);

        _owner = owner;
    }

    @Override
    public void enterStartState()
    {
        getState().entry(this);
        return;
    }

    public void ACK(TcpSegment segment)
    {
        _transition = "ACK";
        getState().ACK(this, segment);
        _transition = "";
        return;
    }

    public void Accepted()
    {
        _transition = "Accepted";
        getState().Accepted(this);
        _transition = "";
        return;
    }

    public void AckTimeout()
    {
        _transition = "AckTimeout";
        getState().AckTimeout(this);
        _transition = "";
        return;
    }

    public void Close()
    {
        _transition = "Close";
        getState().Close(this);
        _transition = "";
        return;
    }

    public void CloseAckTimeout()
    {
        _transition = "CloseAckTimeout";
        getState().CloseAckTimeout(this);
        _transition = "";
        return;
    }

    public void CloseTimeout()
    {
        _transition = "CloseTimeout";
        getState().CloseTimeout(this);
        _transition = "";
        return;
    }

    public void ConnAckTimeout()
    {
        _transition = "ConnAckTimeout";
        getState().ConnAckTimeout(this);
        _transition = "";
        return;
    }

    public void FIN(TcpSegment segment)
    {
        _transition = "FIN";
        getState().FIN(this, segment);
        _transition = "";
        return;
    }

    public void FIN_ACK(TcpSegment segment)
    {
        _transition = "FIN_ACK";
        getState().FIN_ACK(this, segment);
        _transition = "";
        return;
    }

    public void Open(int port)
    {
        _transition = "Open";
        getState().Open(this, port);
        _transition = "";
        return;
    }

    public void Open(TcpSegment segment)
    {
        _transition = "Open";
        getState().Open(this, segment);
        _transition = "";
        return;
    }

    public void Open(InetAddress address, int port)
    {
        _transition = "Open";
        getState().Open(this, address, port);
        _transition = "";
        return;
    }

    public void OpenFailed(String reason)
    {
        _transition = "OpenFailed";
        getState().OpenFailed(this, reason);
        _transition = "";
        return;
    }

    public void Opened(InetAddress address, int port)
    {
        _transition = "Opened";
        getState().Opened(this, address, port);
        _transition = "";
        return;
    }

    public void PSH(TcpSegment segment)
    {
        _transition = "PSH";
        getState().PSH(this, segment);
        _transition = "";
        return;
    }

    public void PSH_ACK(TcpSegment segment)
    {
        _transition = "PSH_ACK";
        getState().PSH_ACK(this, segment);
        _transition = "";
        return;
    }

    public void RST(TcpSegment segment)
    {
        _transition = "RST";
        getState().RST(this, segment);
        _transition = "";
        return;
    }

    public void RST_ACK(TcpSegment segment)
    {
        _transition = "RST_ACK";
        getState().RST_ACK(this, segment);
        _transition = "";
        return;
    }

    public void SYN(TcpSegment segment)
    {
        _transition = "SYN";
        getState().SYN(this, segment);
        _transition = "";
        return;
    }

    public void SYN_ACK(TcpSegment segment)
    {
        _transition = "SYN_ACK";
        getState().SYN_ACK(this, segment);
        _transition = "";
        return;
    }

    public void TransAckTimeout()
    {
        _transition = "TransAckTimeout";
        getState().TransAckTimeout(this);
        _transition = "";
        return;
    }

    public void Transmit(byte[] data, int offset, int size)
    {
        _transition = "Transmit";
        getState().Transmit(this, data, offset, size);
        _transition = "";
        return;
    }

    public void UNDEF(TcpSegment segment)
    {
        _transition = "UNDEF";
        getState().UNDEF(this, segment);
        _transition = "";
        return;
    }

    public void URG(TcpSegment segment)
    {
        _transition = "URG";
        getState().URG(this, segment);
        _transition = "";
        return;
    }

    public TcpConnectionState getState()
        throws statemap.StateUndefinedException
    {
        if (_state == null)
        {
            throw(
                new statemap.StateUndefinedException());
        }

        return ((TcpConnectionState) _state);
    }

    protected TcpConnection getOwner()
    {
        return (_owner);
    }

    public void setOwner(TcpConnection owner)
    {
        if (owner == null)
        {
            throw (
                new NullPointerException(
                    "null owner"));
        }
        else
        {
            _owner = owner;
        }

        return;
    }

//---------------------------------------------------------------
// Member data.
//

    transient private TcpConnection _owner;

    //-----------------------------------------------------------
    // Constants.
    //

    private static final long serialVersionUID = 1L;

//---------------------------------------------------------------
// Inner classes.
//

    public static abstract class TcpConnectionState
        extends statemap.State
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected TcpConnectionState(String name, int id)
        {
            super (name, id);
        }

        protected void entry(TcpConnectionContext context) {}
        protected void exit(TcpConnectionContext context) {}

        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void Accepted(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void AckTimeout(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void Close(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void CloseAckTimeout(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void CloseTimeout(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void ConnAckTimeout(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void FIN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void Open(TcpConnectionContext context, int port)
        {
            Default(context);
        }

        protected void Open(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void Open(TcpConnectionContext context, InetAddress address, int port)
        {
            Default(context);
        }

        protected void OpenFailed(TcpConnectionContext context, String reason)
        {
            Default(context);
        }

        protected void Opened(TcpConnectionContext context, InetAddress address, int port)
        {
            Default(context);
        }

        protected void PSH(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void PSH_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void RST(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void RST_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void SYN(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void SYN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void TransAckTimeout(TcpConnectionContext context)
        {
            Default(context);
        }

        protected void Transmit(TcpConnectionContext context, byte[] data, int offset, int size)
        {
            Default(context);
        }

        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void URG(TcpConnectionContext context, TcpSegment segment)
        {
            Default(context);
        }

        protected void Default(TcpConnectionContext context)
        {
            throw (
                new statemap.TransitionUndefinedException(
                    "State: " +
                    context.getState().getName() +
                    ", Transition: " +
                    context.getTransition()));
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
    // Constants.
    //

        private static final long serialVersionUID = 1L;
    }

    /* package */ static abstract class MainMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final MainMap_CLOSED CLOSED =
            new MainMap_CLOSED("MainMap.CLOSED", 0);
        public static final MainMap_ServiceOpening ServiceOpening =
            new MainMap_ServiceOpening("MainMap.ServiceOpening", 1);
        public static final MainMap_ClientOpening ClientOpening =
            new MainMap_ClientOpening("MainMap.ClientOpening", 2);
        public static final MainMap_LISTEN LISTEN =
            new MainMap_LISTEN("MainMap.LISTEN", 3);
        public static final MainMap_SYN_RCVD SYN_RCVD =
            new MainMap_SYN_RCVD("MainMap.SYN_RCVD", 4);
        public static final MainMap_SYN_SENT SYN_SENT =
            new MainMap_SYN_SENT("MainMap.SYN_SENT", 5);
        public static final MainMap_ESTABLISHED ESTABLISHED =
            new MainMap_ESTABLISHED("MainMap.ESTABLISHED", 6);
        public static final MainMap_Transmitting Transmitting =
            new MainMap_Transmitting("MainMap.Transmitting", 7);
        public static final MainMap_CLOSE_WAIT CLOSE_WAIT =
            new MainMap_CLOSE_WAIT("MainMap.CLOSE_WAIT", 8);
        public static final MainMap_LAST_ACK LAST_ACK =
            new MainMap_LAST_ACK("MainMap.LAST_ACK", 9);
        public static final MainMap_FIN_WAIT_1 FIN_WAIT_1 =
            new MainMap_FIN_WAIT_1("MainMap.FIN_WAIT_1", 10);
        public static final MainMap_FIN_WAIT_2 FIN_WAIT_2 =
            new MainMap_FIN_WAIT_2("MainMap.FIN_WAIT_2", 11);
        public static final MainMap_CLOSING CLOSING =
            new MainMap_CLOSING("MainMap.CLOSING", 12);
        public static final MainMap_TIME_WAIT TIME_WAIT =
            new MainMap_TIME_WAIT("MainMap.TIME_WAIT", 13);
    }

    protected static class MainMap_Default
        extends TcpConnectionState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected MainMap_Default(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Open(TcpConnectionContext context, int port)
        {
            TcpConnection ctxt = context.getOwner();

            TcpConnectionState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.openFailed("already open");
            }
            finally
            {
                context.setState(endState);
            }


            return;
        }

        @Override
        protected void Open(TcpConnectionContext context, InetAddress address, int port)
        {
            TcpConnection ctxt = context.getOwner();

            TcpConnectionState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.openFailed("already open");
            }
            finally
            {
                context.setState(endState);
            }


            return;
        }

        @Override
        protected void Transmit(TcpConnectionContext context, byte[] data, int offset, int size)
        {
            TcpConnection ctxt = context.getOwner();

            TcpConnectionState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.transmitFailed("connection not established");
            }
            finally
            {
                context.setState(endState);
            }


            return;
        }

        @Override
        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void SYN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void PSH(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void URG(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void FIN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void SYN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void PSH_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }
            return;
        }

        @Override
        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == false ||
       segment.getSourcePort() != ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            else
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.RST, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("connection reset");
                }
                finally
                {
                    context.setState(endState);
                }

            }
            return;
        }

        @Override
        protected void RST(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.closed("connection reset by peer");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void RST_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.closed("connection reset by peer");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void ConnAckTimeout(TcpConnectionContext context)
        {


            return;
        }

        @Override
        protected void TransAckTimeout(TcpConnectionContext context)
        {


            return;
        }

        @Override
        protected void CloseAckTimeout(TcpConnectionContext context)
        {


            return;
        }

        @Override
        protected void CloseTimeout(TcpConnectionContext context)
        {


            return;
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_CLOSED
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_CLOSED(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {


            return;
        }

        @Override
        protected void Open(TcpConnectionContext context, int port)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.openServerSocket(port);
            }
            finally
            {
                context.setState(MainMap.ServiceOpening);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void Open(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.sendAcceptSynAck(segment);
            }
            finally
            {
                context.setState(MainMap.SYN_RCVD);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void Open(TcpConnectionContext context, InetAddress address, int port)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.openClientSocket(address, port);
            }
            finally
            {
                context.setState(MainMap.ClientOpening);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_ServiceOpening
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_ServiceOpening(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Accepted(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.openSuccess();
            }
            finally
            {
                context.setState(MainMap.LISTEN);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void OpenFailed(TcpConnectionContext context, String reason)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.openFailed(reason);
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_ClientOpening
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_ClientOpening(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void OpenFailed(TcpConnectionContext context, String reason)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.openFailed(reason);
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void Opened(TcpConnectionContext context, InetAddress address, int port)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.SYN, null, 0, 0, address, port, null);
            }
            finally
            {
                context.setState(MainMap.SYN_SENT);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_LISTEN
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_LISTEN(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.closed("");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void RST(TcpConnectionContext context, TcpSegment segment)
        {


            return;
        }

        @Override
        protected void SYN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            TcpConnectionState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.accept(segment);
            }
            finally
            {
                context.setState(endState);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_SYN_RCVD
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_SYN_RCVD(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("ACK_TIMER");
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.accepted();
                }
                finally
                {
                    context.setState(MainMap.ESTABLISHED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.ACK(context, segment);
            }

            return;
        }

        @Override
        protected void AckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.openFailed("acknowledge timeout");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.FIN, null, 0, 0, null, -1, null);
            }
            finally
            {
                context.setState(MainMap.FIN_WAIT_1);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void RST(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.clearListener();
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_SYN_SENT
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_SYN_SENT(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CONN_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CONN_ACK_TIMER");
            return;
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.closed("");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void ConnAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.openFailed("acknowledge timeout");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void SYN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.setDestinationPort(segment);
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                    ctxt.openSuccess();
                }
                finally
                {
                    context.setState(MainMap.ESTABLISHED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.SYN_ACK(context, segment);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_ESTABLISHED
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_ESTABLISHED(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.FIN, null, 0, 0, null, 0, null);
            }
            finally
            {
                context.setState(MainMap.FIN_WAIT_1);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress())
            == true &&
       segment.getSourcePort() == ctxt.getFarPort())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                    ctxt.halfClosed();
                }
                finally
                {
                    context.setState(MainMap.CLOSE_WAIT);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN(context, segment);
            }

            return;
        }

        @Override
        protected void PSH(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress())
            == true &&
       segment.getSourcePort() == ctxt.getFarPort())
            {
                TcpConnectionState endState = context.getState();
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                    ctxt.receive(segment);
                }
                finally
                {
                    context.setState(endState);
                }

            }

            else
            {
                super.PSH(context, segment);
            }

            return;
        }

        @Override
        protected void Transmit(TcpConnectionContext context, byte[] data, int offset, int size)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.PSH, data, offset, size, null, 0, null);
            }
            finally
            {
                context.setState(MainMap.Transmitting);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_Transmitting
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_Transmitting(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("TRANS_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("TRANS_ACK_TIMER");
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.transmitted();
                }
                finally
                {
                    context.setState(MainMap.ESTABLISHED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.ACK(context, segment);
            }

            return;
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.FIN, null, 0, 0, null, 0, null);
            }
            finally
            {
                context.setState(MainMap.FIN_WAIT_1);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                    ctxt.halfClosed();
                }
                finally
                {
                    context.setState(MainMap.CLOSE_WAIT);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN(context, segment);
            }

            return;
        }

        @Override
        protected void PSH_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                    ctxt.transmitted();
                    ctxt.receive(segment);
                }
                finally
                {
                    context.setState(MainMap.ESTABLISHED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.PSH_ACK(context, segment);
            }

            return;
        }

        @Override
        protected void TransAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.transmitFailed("peer did not acknowledge");
                ctxt.closed("connection lost");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_CLOSE_WAIT
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_CLOSE_WAIT(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Close(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.send(TcpSegment.FIN, null, 0, 0, null, 0, null);
            }
            finally
            {
                context.setState(MainMap.LAST_ACK);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_LAST_ACK
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_LAST_ACK(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CLOSE_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CLOSE_ACK_TIMER");
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.FIN_ACK, null, 0, 0, segment);
                    ctxt.closeSocket();
                    ctxt.closed("");
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.ACK(context, segment);
            }

            return;
        }

        @Override
        protected void CloseAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
                ctxt.closed("");
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_FIN_WAIT_1
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_FIN_WAIT_1(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CLOSE_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CLOSE_ACK_TIMER");
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                // No actions.
                context.setState(MainMap.FIN_WAIT_2);
                (context.getState()).entry(context);
            }

            else
            {
                super.ACK(context, segment);
            }

            return;
        }

        @Override
        protected void CloseAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
            }
            finally
            {
                context.setState(MainMap.FIN_WAIT_2);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                }
                finally
                {
                    context.setState(MainMap.CLOSING);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN(context, segment);
            }

            return;
        }

        @Override
        protected void FIN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                }
                finally
                {
                    context.setState(MainMap.TIME_WAIT);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN_ACK(context, segment);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_FIN_WAIT_2
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_FIN_WAIT_2(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CLOSE_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CLOSE_ACK_TIMER");
            return;
        }

        @Override
        protected void CloseAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void FIN(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.send(TcpSegment.ACK, null, 0, 0, segment);
                }
                finally
                {
                    context.setState(MainMap.TIME_WAIT);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN(context, segment);
            }

            return;
        }

        @Override
        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_CLOSING
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_CLOSING(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CLOSE_ACK_TIMER", TcpConnection.ACK_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CLOSE_ACK_TIMER");
            return;
        }

        @Override
        protected void ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                // No actions.
                context.setState(MainMap.TIME_WAIT);
                (context.getState()).entry(context);
            }

            else
            {
                super.ACK(context, segment);
            }

            return;
        }

        @Override
        protected void CloseAckTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
            }
            finally
            {
                context.setState(MainMap.TIME_WAIT);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class MainMap_TIME_WAIT
        extends MainMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private MainMap_TIME_WAIT(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(TcpConnectionContext context)
            {
                TcpConnection ctxt = context.getOwner();

            ctxt.startTimer("CLOSE_TIMER", TcpConnection.CLOSE_TIMEOUT);
            return;
        }

        @Override
        protected void exit(TcpConnectionContext context)
            {
            TcpConnection ctxt = context.getOwner();

            ctxt.stopTimer("CLOSE_TIMER");
            return;
        }

        @Override
        protected void CloseTimeout(TcpConnectionContext context)
        {
            TcpConnection ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.closeSocket();
            }
            finally
            {
                context.setState(MainMap.CLOSED);
                (context.getState()).entry(context);
            }


            return;
        }

        @Override
        protected void FIN_ACK(TcpConnectionContext context, TcpSegment segment)
        {
            TcpConnection ctxt = context.getOwner();

            if ((segment.getSourceAddress()).equals(ctxt.getFarAddress()) == true &&
       segment.getSourcePort() == ctxt.getFarPort() &&
       segment.getAcknowledgeNumber() == ctxt.getSequenceNumber())
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.closeSocket();
                }
                finally
                {
                    context.setState(MainMap.CLOSED);
                    (context.getState()).entry(context);
                }

            }

            else
            {
                super.FIN_ACK(context, segment);
            }

            return;
        }

        @Override
        protected void UNDEF(TcpConnectionContext context, TcpSegment segment)
        {


            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
